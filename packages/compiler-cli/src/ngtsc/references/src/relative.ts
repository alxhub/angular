/// <reference types="node" />
import {Expression, ExternalExpr, ExternalReference, WrappedNodeExpr} from '@angular/compiler';
import * as path from 'path';
import * as ts from 'typescript';

import {ImportMode, Reference} from './api';
import {pickIdentifier} from './util';

const TS_DTS_JS_EXTENSION = /(\.d)?\.ts|\.js$/;

/**
 * A reference to a node only, without any ability to get an `Expression` representing that node.
 *
 * This is used for returning references to things like method declarations, which are not directly
 * referenceable.
 */
export class NodeReference<T extends ts.Node = ts.Node> extends Reference<T> {
  constructor(node: T, readonly moduleName: string|null) { super(node); }

  toExpression(context: ts.SourceFile): null { return null; }

  addIdentifier(identifier: ts.Identifier): void {}
}

/**
 * A reference to a node which has a `ts.Identifier` and can be resolved to an `Expression`.
 *
 * Imports generated by `RelativeReference`s are always relative.
 */
export class RelativeReference<T extends ts.Node = ts.Node> extends Reference<T> {
  protected identifiers: ts.Identifier[] = [];

  constructor(node: T, protected primaryIdentifier: ts.Identifier) { super(node); }

  readonly expressable = true;

  toExpression(context: ts.SourceFile, importMode: ImportMode = ImportMode.UseExistingImport):
      Expression {
    const localIdentifier =
        pickIdentifier(context, this.primaryIdentifier, this.identifiers, importMode);
    if (localIdentifier !== null) {
      return new WrappedNodeExpr(localIdentifier);
    } else {
      // Relative import from context -> this.node.getSourceFile().
      // TODO(alxhub): investigate the impact of multiple source roots here.
      // TODO(alxhub): investigate the need to map such paths via the Host for proper g3 support.
      let relative =
          path.posix.relative(path.dirname(context.fileName), this.node.getSourceFile().fileName)
              .replace(TS_DTS_JS_EXTENSION, '');

      // path.relative() does not include the leading './'.
      if (!relative.startsWith('.')) {
        relative = `./${relative}`;
      }

      // path.relative() returns the empty string (converted to './' above) if the two paths are the
      // same.
      if (relative === './') {
        // Same file after all.
        return new WrappedNodeExpr(this.primaryIdentifier);
      } else {
        return new ExternalExpr(new ExternalReference(relative, this.primaryIdentifier.text));
      }
    }
  }

  addIdentifier(identifier: ts.Identifier): void { this.identifiers.push(identifier); }
}
